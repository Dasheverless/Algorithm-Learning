## 题意
已知：构造字符串，操作是去掉最后一个字符或直接连接原字符  
求：长度为k且字典序最小的生成字符串
## 分析
已知条件  
n， k，源字符串  
特殊条件：构造字符串的方式  
所求：求字典序最小的生成字符串  
其他：n 5 * 10^5  
## 思路
题目涉及构造，切入点比较明显，体验法+特殊条件  
体验法：对于每一个字符，要么保留当前字符，要么删除当前字符，删除的话只能从头开始复制。  
充分必要法：思考所求，截断了一次之后不会发生二次截断，因为截断时会把第一个字符放在当前位置，而之前已经按照这样比较过了，所以保证截断是最优的，这时只需要确定截断长度即可。  
由此可得当前字符字典序必须比首字符小， 否则就可以复制起始字符从而生成字典序更小的字符串。  
**这样对吗？**  
正确性无疑  
**这样就够了吗？**  
如果当前字符与首字符相等呢？显然此时也有两个选择，如果选择copy就要从第二个字符开始考察，直到看到一个不相等的字符。此时需要判断两个字符字典序大小  
如果源字符串字典序大于生成字符串字典序则保留copy操作，break  
否则就放弃copy操作，进行下一次循环  
**这样就够了吗？**  
每种情况都处理完了，应该够了  
**只能这样吗？**  
没思路时思考  
**这样然后呢？**  
遍历每个字符，比较与首字符的大小  
如果大于首字符直接break  
如果等于则向后考察
## 总结
找方向简化，如果自己都没思考清楚的，写起来绝对是浪费时间。
## 代码
```C++
int n, k;
string s;
void solve()
{
    cin >> n >> k >> s;
    int start = 0, m = 1;
    for (int i = 1; i < n; i++)
    {
        if (s[i] > s[0])
        {
            break;
        }
        else if (s[i] == s[0])
        {
            start = 0;
            while (i < n && s[++i] == s[++start % m]);
            if (i == n || s[i] > s[start % m])
            {
                break;
            }
            i--;
            m = i;
        }
        m++;
    }
    for (int i = 0; i < k; i++)
    {
        printf("%c", s[i % m]);
    }
    printf("\n");
}
```
